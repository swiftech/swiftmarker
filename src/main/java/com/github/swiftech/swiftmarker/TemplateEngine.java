package com.github.swiftech.swiftmarker;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.List;import java.util.Map;/** * 简易模板引擎 * 规则： * ${xxx} 表示直接用对应的值进行替换 * 如果用$[xxx]开头的表示用此行作为模板遍历数组 * 注意：一行只能存在一个数组遍历的情况，如果有多个，只处理第一个。 * * @author swiftech */public class TemplateEngine {    private static final String TEMPLATE_ARR_END = "$[]";    private Logger log = LoggerFactory.getLogger(TemplateEngine.class);    private String template;    private Config config = new Config();    public TemplateEngine() {    }    public TemplateEngine(String template) {        this.template = template;    }    public TemplateEngine(String template, Config config) {        this.template = template;        this.config = config;    }    public String eachLine(DataModelHandler lineHandler) {        if (StringUtils.isBlank(template)) {            throw new RuntimeException("Template not loaded");        }        StringBuilder outputBuf = new StringBuilder();        log.info("Template: ");        System.out.println(template);        String[] lines;        if ("\r\n".equals(config.getInputLineBreaker())) {            lines = StringUtils.splitByWholeSeparatorPreserveAllTokens(template, config.getInputLineBreaker());        }        else {            lines = StringUtils.splitPreserveAllTokens(template, config.getInputLineBreaker());        }        if (lines == null || lines.length == 0) {            return "";        }        log.info("Start to process line by line: ");        StringBuilder stanza = null;        List<Map<String, String>> linesValues = null;        boolean inProcessMultiLine = false;        for (String line : lines) {            log.info(String.format("  Line: '%s'%n", line));            // 先判断是否存在数组            String arrKey = StringUtils.substringBetween(line, "$[", "]");            // 处理数组-首行            if (StringUtils.isNotBlank(arrKey)) {                log.info("    Multi line");                log.debug("    Array params: " + arrKey);                stanza = new StringBuilder();                // 去掉数组标识头部后的行模板                String subTemp = StringUtils.substringAfter(line, "$[" + arrKey + "]");                linesValues = lineHandler.onLines(arrKey);                // 直接结束了                if (StringUtils.endsWith(line.trim(), TEMPLATE_ARR_END)) {                    log.debug("    end in line");                    processLineValues(linesValues, StringUtils.substringBefore(subTemp, "$[]"), outputBuf);                }                else {                    log.debug("    continue lines");                    inProcessMultiLine = true;                    if (StringUtils.isBlank(subTemp.trim())) {                        // 单独的数组头，这一行不需要作为模板处理                        continue;                    }                    else {                        stanza.append(subTemp).append(StringUtils.LF);                    }                }            }            else if (inProcessMultiLine) {                // 处理数组-末行                if (StringUtils.endsWith(line.trim(), TEMPLATE_ARR_END)) {                    log.debug("  >");                    // 跳出数组段模板循环                    inProcessMultiLine = false;                    if (TEMPLATE_ARR_END.equals(line.trim())) {                        // 单独的数组尾，这一行不需要作为模板处理                    }                    else {                        log.debug("    the end");                        stanza.append(StringUtils.substringBefore(line, TEMPLATE_ARR_END));                    }                    processLineValues(linesValues, stanza.toString(), outputBuf);                }                // 处理数组-中间行                else {                    log.debug("    ...");                    stanza.append(line).append(StringUtils.LF);                    continue;// 等待下一行一起处理                }            }            // 处理常规参数            else {                log.debug("    Single line");                processLine(line, lineHandler, outputBuf);            }        }        return outputBuf.toString();    }    private void processLine(String line, DataModelHandler lineHandler, StringBuilder buf) {        if (StringUtils.isBlank(line)) {            // 处理空行            buf.append(line).append(config.getOutputLineBreaker());            return;        }        String[] keys = StringUtils.substringsBetween(line, "${", "}");        // 没有参数，原样不动的返回一行        if (keys == null || keys.length == 0) {            log.warn("    No place holders for this line.");            buf.append(line).append(config.getOutputLineBreaker());            return;        }        log.info("    String params: " + StringUtils.join(keys, ","));        List<String> values = lineHandler.onLine(keys);        String retLine = TextUtils.replaceWith(line, keys, values.toArray(new String[0]));        log.info("    Render: ");        System.out.println(retLine);        buf.append(retLine).append(config.getOutputLineBreaker());    }    /**     * @param linesValues    根据数组key获取得到的数据模型数组     * @param templateStanza 模板片段     * @param outBuf         输出缓存     */    private void processLineValues(List<Map<String, String>> linesValues,                                   String templateStanza,                                   StringBuilder outBuf) {        if (linesValues == null || linesValues.isEmpty()) {            // 没有提供参数值，直接输出模板            outBuf.append(templateStanza).append(config.getOutputLineBreaker());        }        else {            for (Map<String, String> params : linesValues) {                String retLine = TextUtils.replaceWith(templateStanza,                        params.keySet().toArray(new String[0]),                        params.values().toArray(new String[0]));                log.info("    Render：");                System.out.println(retLine);                outBuf.append(retLine).append(config.getOutputLineBreaker());            }        }    }    public void setTemplate(String template) {        this.template = template;    }    public void setConfig(Config config) {        this.config = config;    }}